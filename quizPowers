#!/usr/bin/python2.7

import argparse
import os
import sys
import subprocess
import textwrap
import time
import random
import math
from operator import itemgetter
import cmd
import json
import yaml
import copy

ROOT = 0
EXP = 1
POWER = 2
SHUFFLE = 3
ASK_FOR_ROOT = 4

ANSWER_TIME = 0
WAS_CORRECT = 1

ASK_CONTINUE = 0
GET_ANSWER = 1

kEpsilon = 1.0e-12

quickWaitCycles = 3
delayWaitCycles = 7

# Make sure this is an even number
#
maxQListSize = 8

# Temporary filename for saving state
#
saveStateFile = "quizPowers.json"

# Global vars
#
quizList = []
fullQuizList = []
askAgainQuickList = []
askAgainDelayList = []
answerDict = {}
fqListInd = 0

def stndNormDist(x) :
    return 1.0/math.sqrt(math.pow(math.e, x*x))

def genWeights(n) :
    if n <= 0 :
        return []
    result = [1.0]
    scale = float(n-1 if n <= 3 else 3)
    i = 1
    while i < n :
        result.append(stndNormDist(scale*float(i)/float(n-1)))
        i += 1
    return result

def weightedAvg(list) :
    weights = genWeights(len(list))

    wList = []
    i = 0
    while i < len(list) :
        wList.append(weights[i] * list[i])
        i += 1
    return math.fsum(wList) / math.fsum(weights)

def rootQ(power, expn) :
    return str(power) + '^(1/' + str(expn) + ')'

def powerQ(root, expn) :
    return str(root) + '^' + str(expn)

def getSlowestAnswers(n) :
    if n <= 0 :
        return []

    qList = []
    for key in answerDict :
        qList.append(list(answerDict[key][0]))
        times = []
        i = 1
        while i < len(answerDict[key]) :
            if answerDict[key][i][WAS_CORRECT] :
                times.append(answerDict[key][i][ANSWER_TIME])
            i += 1
        if times == [] :
            qList.pop()
            continue
        times.reverse()
        avgAnswerTime = weightedAvg(times)
        qList[-1][SHUFFLE] = avgAnswerTime

    qList.sort(key=itemgetter(SHUFFLE))
    qList.reverse()

    return qList[:n]

def growQuizList() :
    global fqListInd
    global quizList

    # If there are powers in the full list that have not
    # been asked yet draw questions from those.
    #
    if fqListInd < len(fullQuizList) :

        if len(quizList) < maxQListSize/2 :
            while len(quizList) < maxQListSize and fqListInd < len(fullQuizList) :
                r = fullQuizList[fqListInd][ROOT]
                e = fullQuizList[fqListInd][EXP]
                x = fullQuizList[fqListInd][POWER]
                quizList.append([r, e, x, 0.0, True])
                quizList.append([r, e, x, 0.0, False])
                fqListInd += 1
            i = 0
            while i < len(quizList) :
                quizList[i][SHUFFLE] = random.random()
                i += 1
            quizList.sort(key=itemgetter(SHUFFLE))
            return True
        else :
            return False
           
    # Grows up to max size of quizList if quizList is empty
    #
    elif len(quizList) == 0 :
        quizList = getSlowestAnswers(maxQListSize)
        i = 0
        while i < len(quizList) :
            quizList[i][SHUFFLE] = random.random()
            i += 1
        quizList.sort(key=itemgetter(SHUFFLE))
        return len(quizList) > 0

    else :
        return False

def printQuizList() :
    global quizList
    for q in quizList :
        print q

class powersQuiz(cmd.Cmd) :
    'quiz user on powers of integers'

    def __init__(self) :
	self.startTime = 0.0
	self.endTime = 0.0

	self.root = 1
	self.exponent = 1
	self.power = 1
	self.askForRoot = True
	self.correctAnswer = 1
        self.qStr = ""
	self.lastWasWrong = False

        self.prompt = "Begin quiz? "
	self.quizState = ASK_CONTINUE
	self.quickAsk = -1

        cmd.Cmd.__init__(self)

    def readState(self) :
        global quizList
        global fullQuizList
        global askAgainQuickList
        global askAgainDelayList
        global answerDict
        global fqListInd

        with open(saveStateFile, 'r') as f :
            qQuiz = f.read()
        dumpDict = yaml.safe_load(qQuiz)

        quizList = dumpDict.pop("quizList")
        fullQuizList = dumpDict.pop("fullQuizList")
        askAgainQuickList = dumpDict.pop("askAgainQuickList")
        askAgainDelayList = dumpDict.pop("askAgainDelayList")
        fqListInd = dumpDict.pop("fqListInd")
        #
        self.startTime = dumpDict.pop("self.startTime")
        self.endTime = dumpDict.pop("self.endTime")
        self.root = dumpDict.pop("self.root")
        self.exponent = dumpDict.pop("self.exponent")
        self.power = dumpDict.pop("self.power")
        self.askForRoot = dumpDict.pop("self.askForRoot")
        self.correctAnswer = dumpDict.pop("self.correctAnswer")
        self.qStr = dumpDict.pop("self.qStr")
        self.lastWasWrong = dumpDict.pop("self.lastWasWrong")
        self.prompt = dumpDict.pop("self.prompt")
        self.quizState = dumpDict.pop("self.quizState")
        self.quickAsk = dumpDict.pop("self.quickAsk")

        answerDict = dumpDict

    def writeState(self) :
        dumpDict = copy.deepcopy(answerDict)

        dumpDict["quizList"] = quizList
        dumpDict["fullQuizList"] = fullQuizList
        dumpDict["askAgainQuickList"] = askAgainQuickList
        dumpDict["askAgainDelayList"] = askAgainDelayList
        dumpDict["fqListInd"] = fqListInd
        #
	dumpDict["self.startTime"] = self.startTime
	dumpDict["self.endTime"] = self.endTime
	dumpDict["self.root"] = self.root
        dumpDict["self.exponent"] = self.exponent
	dumpDict["self.power"] = self.power
	dumpDict["self.askForRoot"] = self.askForRoot
	dumpDict["self.correctAnswer"] = self.correctAnswer
        dumpDict["self.qStr"] = self.qStr
	dumpDict["self.lastWasWrong"] = self.lastWasWrong
        dumpDict["self.prompt"] = self.prompt
	dumpDict["self.quizState"] = self.quizState
	dumpDict["self.quickAsk"] = self.quickAsk

        jQuiz = json.dumps(dumpDict, ensure_ascii=False, sort_keys=True, indent=2, separators=(',',': '))
        with open(saveStateFile, 'w') as f :
            f.write(jQuiz)

    def getNextQuestion(self) :
	if self.quickAsk == 0 :
	    self.root       = askAgainQuickList[0][ROOT]
	    self.exponent   = askAgainQuickList[0][EXP]
	    self.power      = askAgainQuickList[0][POWER]
	    self.askForRoot = askAgainQuickList[0][ASK_FOR_ROOT]
	    askAgainQuickList.pop(0)
	    self.quickAsk = -1 if (len(askAgainQuickList) == 0) else quickWaitCycles
	else :
            growQuizList()
	    self.root       = quizList[-1][ROOT]
	    self.exponent   = quizList[-1][EXP]
	    self.power      = quizList[-1][POWER]
	    self.askForRoot = quizList[-1][ASK_FOR_ROOT]
	    quizList.pop()
	    if self.quickAsk > 0 :
		self.quickAsk -= 1

	if self.askForRoot :
	    self.correctAnswer = self.root
	    self.qStr = rootQ(self.power, self.exponent)
	    self.prompt = self.qStr + '? '
	else :
	    self.correctAnswer = self.power
	    self.qStr = powerQ(self.root, self.exponent)
	    self.prompt = self.qStr + '? '

	self.quizState = GET_ANSWER
	self.wasLastWrong = False
        return True

    def emptyline(self):
        global answerDict
	if self.quizState == ASK_CONTINUE :
	    self.getNextQuestion()
	    self.startTime = time.time()

	elif self.quizState == GET_ANSWER :
	    self.endTime = time.time()
            if answerDict.has_key(self.qStr) :
                answerDict[self.qStr].append(((self.endTime - self.startTime), False))
            else :
                answerDict[self.qStr] = [[self.root, self.exponent, self.power, \
		    0.0, self.askForRoot], ((self.endTime - self.startTime), False)]
	    if not self.lastWasWrong :
		askAgainQuickList.append( \
		    [self.root, self.exponent, self.power, \
		    0.0, self.askForRoot])
	    if self.quickAsk < 0 :
		self.quickAsk = quickWaitCycles
	    self.prompt = 'continue? '
	    self.quizState = ASK_CONTINUE
    
    def default(self, line):
        userAnswer = 0
        global answerDict
	if self.quizState == GET_ANSWER :
	    self.endTime = time.time()
	    try :
		userAnswer = int(line)
	    except ValueError :
		print "Value typed was not an integer"
		self.startTime = time.time()
	    else :
		if userAnswer == self.correctAnswer :
		    print "Correct"
		    self.prompt = 'continue? '
		    self.quizState = ASK_CONTINUE
		else :
		    print "Incorrect"
		    if not self.lastWasWrong :
			askAgainQuickList.append( \
			    [self.root, self.exponent, self.power, \
			    0.0, self.askForRoot])
			self.lastWasWrong = True
			if self.quickAsk < 0 :
			    self.quickAsk = quickWaitCycles

                if answerDict.has_key(self.qStr) :
                    answerDict[self.qStr].append( \
                        ((self.endTime - self.startTime), \
			(userAnswer == self.correctAnswer)))
                else :
                    answerDict[self.qStr] = [[self.root, self.exponent, self.power, \
                        0.0, self.askForRoot], ((self.endTime - self.startTime), \
			(userAnswer == self.correctAnswer))]

                self.startTime = time.time()
	else :
	    print "Unknown command. Try 'help'"
    
    def precmd(self, line):
	return cmd.Cmd.precmd(self, line)
    
    def postcmd(self, stop, line):
	print '***postcmd***'
        print "answerDict..."
        for key in answerDict :
            print key
            print answerDict[key]
        print "quizList..."
        printQuizList()
        '''
        '''
	print ''
	return cmd.Cmd.postcmd(self, stop, line)
    
    def do_repeat(self, line) :
        global fqListInd
        fqListInd = 0
    
    def do_stats(self, line) :
        for key in answerDict :
            print key
            print answerDict[key]

    def do_write(self, line) :
        self.writeState()

    def do_read(self, line) :
        self.readState()

    def do_EOF(self, line):
	"Exit"
	return True

def main():

    # Redefine the exception handling routine so that it does NOT
    # do a trace dump if the user types ^C while the command is running.
    #
    old_excepthook = sys.excepthook
    def new_hook(exceptionType, value, traceback):
        if exceptionType != KeyboardInterrupt and exceptionType != IOError:
            old_excepthook(exceptionType, value, traceback)
        else:
            pass
    sys.excepthook = new_hook

    p = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent('''\
            Quiz the user's memory on squares and cubes, 4th powers etc.
            '''),
        usage="%(prog)s [OPTION]...")

    p.add_argument("--version", action="version", version="0.100")
    p.add_argument("--power", "-n", action="store", type=int, dest="n",
        default=2, nargs='+',
	help="List powers to test user on, eg. squares are 2, cubes 3 etc. (default=2).")
    p.add_argument("--max", "-m", action="store", type=int, dest="m",
        default=31, metavar="M",
	help="Test the Nth power of the integers 2 to M (default=31).")
    p.add_argument("--primes", action="store_true",
        dest="onlyPrimes", default=False,
        help="only test the Nth power of primes" )
    p.add_argument("--limit", action="store", type=float, dest="maxDigits",
        default=-1.0, metavar="MAX",
	help="Limit testing powers to integers of length MAX-digits or less")

    args = p.parse_args()

    rootList = []
    powerList = []

    if type(args.n) == int :
        powerList = [ args.n ]
    else :
        powerList = args.n

    for i in powerList :
        if i < 2 :
            print >> sys.stderr, os.path.basename(sys.argv[0]) + \
                ": error: --power must be greater than or equal to two."
            sys.exit(1)

    if args.m < 2 :
        print >> sys.stderr, os.path.basename(sys.argv[0]) + \
            ": error: the range (--max) must be greater than or equal to two."
        sys.exit(1)

    if args.maxDigits == 0 :
        print >> sys.stderr, os.path.basename(sys.argv[0]) + \
            ": warning: max digits is 0, nothing to print."
        sys.exit(0)

    # Note: this "isPrime" array will be filled with True
    # in the case that we want to display ALL the integers
    # from 2,m 
    #
    isPrime = [True]*(args.m+1)

    # Sieve of Eratosthenes - skipped when wanting to list ALL numbers
    #
    if args.onlyPrimes :
        p = 2
        while p < (args.m / 2) :
            i = 2
            while p*i <= args.m :
                isPrime[p*i] = False
                i += 1
            p += 1
            while not isPrime[p] :
                p += 1

    i = 2
    while i < len(isPrime) :
	if isPrime[i] :
	    rootList.append(i)
	i += 1

    for e in powerList :
	for r in rootList :
            x = pow(r, e)
	    if args.maxDigits > 0.0 and math.log(x, 10) > args.maxDigits - kEpsilon :
		continue
            fullQuizList.append((r, e, x))
    fullQuizList.sort(key=itemgetter(POWER))
    ### print fullQuizList

    random.seed()

    growQuizList()
    powersQuiz().cmdloop()
    sys.exit(0)

if __name__ == '__main__':
    main()
